\documentclass[polish,polish,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{anysize}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor} % do komentarzy

\marginsize{2.5cm}{2.5cm}{2cm}{2cm}

\title{Symulator tomografu komputerowego}
\author{Przemysław Ambroży, Błażej Celmer}

\begin{document} 
	\maketitle
	
	\section{Wstęp}
		Ćwiczenie zakłada zasymulowanie tomografu komputerowego. 
		Korzystając z obrazów i zdjęć postaramy się wygenerować ich sinogram, 
		który reprezentuje dane odczytane z detektorów tomografu.
		Następnie, przekształcimy go do postaci wynikowej -- czytelnej dla człowieka.
 	
	\section{Model}
			\begin{figure}[h]
				\centering
				\includegraphics[scale=0.7]{img/model.png}
				\caption{model stożkowy}
			\end{figure}
		Zastosowany został model stożkowy (rysunek 1.).
		 Zakłada on wykorzystanie jednego emitera,
		  który współpracuje ze wszystkimi detektorami, tworząc wspomniany stożek 
		  (W przeciwieństwie do modelu równoległego, gdzie każdy detektor posiada własny emiter).
		
	\section{Program}
		\subsection{Środowisko}
			Do zasymulowania tomografu skorzystaliśmy z języka Python w środowisku Jupyter Notebook,
			 co pozwoliło niskim kosztem uzyskać interfejs użytkownika.
			 Skorzystaliśmy również z bibliotek, które oferowały dodatkowe funkcjonalności, m.in.:
			
			\begin{description}
				\item[numpy] funkcje i stałe matematyczne
				\item[matplotlib] wyświetlanie grafik
				\item[ipywidgets] interfejs użytkownika
				\item[pydicom] odczyt i zapis plików DICOM
			\end{description}
			
			\subsection{Opis działania}
				\subsubsection{Sinogram}
				
				Sinogram, jest to tablica danych, 
				gdzie każdy wiersz to jedna iteracja (pozycja emitera), 
				a każda kolumna oznacza jeden detektor.
				Aby otrzymać sinogram, należy wykonać n iteracji, 
				w których emiter wraz z~detektorami będzie się stopniowo przesuwał po okręgu, 
				aż obrócimy cały układ o 180 stopni. 
				Podczas każdej iteracji wyznaczamy współrzędne punktów, w których znajduje się emiter $E$ oraz detektory $D_i$.
				\begin{center}
					\begin{tabular} {l l l}
						$ E = [ x_E, y_E ] $ 	& \hspace{2cm}	 &	$ D_i = [x_{D_i}, y_{D_i}] $
						\\
						$ x_E = r \times \cos{\alpha} $ 	& \hspace{2cm}	 &	 $ x_{D_i} = r \times \cos{\big(\alpha + \pi - \frac{\phi}{2} + i \times \frac{\phi}{n-1}\big)} $
						 \\ 
						$ y_E = r \times \sin{\alpha} $ 	& \hspace{2cm}	 &	 $ y_{D_i} =  r \times \sin{\big(\alpha + \pi - \frac{\phi}{2} + i \times \frac{\phi}{n-1}\big)}$ 
						\\
					\end{tabular}
				\end{center}
				gdzie: \\
				\indent $r$ -- połowa przekątnej obrazu, \\
				\indent $\alpha$ -- kąt przesunięcia systemu względem obrazu, \\
				\indent $\phi$ -- rozpiętość kątowa układu detektorów. \\ \\
				Wyznaczone współrzędne zakładają punkt $(0,0)$, jako środek systemu/obrazu.
				 Należy przekształcić je do układu współrzędnych obrazu,
				  gdzie punkt $(0,0)$ znajduje się w jednym z narożników.
				
				Aby pobrać dane z obiektu znajdującego się między emiterem a detektorami (w naszym przypadku z obrazka), wykorzystujemy algorytm \textbf{Bresenhama}. Służy on do wyznaczenia pikseli znajdujących się między dwoma punktami. Przechodzi iteracyjnie przez wszystkie wartości na jednej osi (np. OX, jeśli obrazek jest szerszy niż wyższy). W każdym kroku decyduje, czy wykonać tylko ruch wzdłuż jednej osi (poziomo/pionowo), czy obu (na ukos).
				
				\begin{figure}[!h]
					\centering
					\begin{minipage}{0.4\linewidth}
						\begin{lstlisting}[language=Python, frame=single]
for i in range(x1, x2):
    points.append((i, j))
    if e > 0:
        j += m
        e += 2 * (dy - dx)
    else:
        e += 2 * dy
						\end{lstlisting}
						\caption{Fragment kodu algorytmu}
					\end{minipage}
					\hfill
					\begin{minipage}{0.45\linewidth}
						\includegraphics[width=\textwidth]{img/bresenham.png}
						\caption{Przykład działania -- znajdowanie pikseli między dwoma czerwonymi}
					\end{minipage}
				\end{figure}
				
				Znając wszystkie piksele leżące między emiterem, a detektorem, 
				sumujemy ich jasność i zapisujemy w odpowiednim miejscu sinogramu.
				Na koniec normalizujemy wszystkie dane, tak aby wartości były z~przedziału od~0~do~1. W tym celu znajdujemy największą wartość (najjaśniejszy piksel) i dzielimy przez nią pozostałe.
				
				\subsubsection{Obraz wynikowy}
				Sinogram nie jest zrozumiały dla człowieka, 
				dlatego należy go przekształcić.
				Zaczynamy od czarnego obrazu i znów przejdziemy przez n iteracji.
				Każdej iteracji przypisana będzie pozycja emitera wraz z~detektorami 
				(będą to te same pozycje, co podczas generowania sinogramu).
				Wyznaczamy linie przechodzące przez obraz między emiterem i detektorami (algorytm Bresenhama).
				Każdy piksel, przez który przechodzi linia będzie rozjaśniony o wartość odczytaną z sinogramu 
				(dla danego detektora w danej iteracji). 
				Nałożenie wszystkich linii na obrazie, stworzy obraz wynikowy.
				
				\begin{figure}[!h]
					\centering
					\begin{minipage}{0.45\linewidth}
						\includegraphics[width=\linewidth]{../tomograf-zdjecia/Shepp_logan.jpg} 
						\caption{obraz wejściowy}
					\end{minipage}
					\hfill
					\begin{minipage}{0.45\linewidth}
						\includegraphics[width=\linewidth]{img/out_1.png}
						\caption{obraz wyjściowy -- 1. iteracja}
					\end{minipage}
				\end{figure} 
				
				\begin{figure}[!h]
					\centering
					\begin{minipage}{0.45\linewidth}
						\includegraphics[width=\linewidth]{img/out_30.png}
						\caption{obraz wyjściowy -- 30. iteracja}
					\end{minipage}
					\hfill
					\begin{minipage}{0.45\linewidth}
						\includegraphics[width=\linewidth]{img/out_90.png}
						\caption{obraz wyjściowy -- 90. (ostatnia) iteracja}
					\end{minipage}
				\end{figure}
			
			\subsection{Standard DICOM}
\end{document}
