\documentclass[polish,polish,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{anysize}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor} % do komentarzy

\marginsize{2cm}{2cm}{2cm}{2cm}

\title{Symulator tomografu komputerowego}
\author{Przemysław Ambroży, Błażej Celmer}

\begin{document} 
	\maketitle
	
 	\section{Model}
		\begin{center}
			\includegraphics[scale=0.7]{img/model.png} \\
			\small{rys. 1. model stożkowy}
		\end{center}
		Zastosowany został model stożkowy (rys. 1.).
		 Zakłada on wykorzystanie jednego emitera,
		  który współpracuje ze wszystkimi detektorami, tworząc wspomniany stożek 
		  (W przeciwieństwie do modelu równoległego, gdzie każdy detektor posiada własny emiter).
		 {\color{red}  coś bym tu jeszcze dopisał }
		
	\section{Program}
		\subsection{Środowisko}
			Do zasymulowania tomografu skorzystaliśmy z języka Python w środowisku Jupyter Notebook,
			 co pozwoliło niskim kosztem uzyskać interfejs użytkownika.
			 Skorzystaliśmy również z bibliotek, które oferowały dodatkowe funkcjonalności, m.in.:
			
			\begin{description}
				\item[numpy] funkcje i stałe matematyczne
				\item[matplotlib] wyświetlanie grafik
				\item[ipywidgets] interfejs użytkownika
				\item[pydicom] odczyt i zapis plików DICOM
			\end{description}
			
			\subsection{Opis działania}
				\subsubsection{Sinogram}
				
				Sinogram, jest to tablica danych, 
				gdzie każdy wiersz to jedna iteracja (pozycja emitera), 
				a każda kolumna oznacza jeden detektor.
				Aby otrzymać sinogram, należy wykonać n iteracji, 
				w których emiter wraz z~detektorami będzie się stopniowo przesuwał po okręgu, 
				aż obrócimy cały układ o 180 stopni. 
				Podczas każdej iteracji wyznaczamy współrzędne punktów, w których znajduje się emiter oraz detektory.
				
				{\color{red} Opis wyznaczana współrzędnych}
				
				Aby pobrać dane z obiektu znajdującego się między emiterem a detektorami (w naszym przypadku z obrazka), wykorzystujemy algorytm \textbf{Bresenhama}. Służy on do wyznaczenia pikseli znajdujących się między dwoma punktami. Przechodzi iteracyjnie przez wszystkie wartości na jednej osi (np. OX, jeśli obrazek jest szerszy niż wyższy). W każdym kroku decyduje, czy wykonać tylko ruch wzdłuż jednej osi (poziomo/pionowo), czy obu (na ukos).
				
				\begin{figure}[!h]
					\centering
					\begin{minipage}{0.4\linewidth}
						\begin{lstlisting}[language=Python, frame=single]
for i in range(x1, x2):
    points.append((i, j))
    if e > 0:
        j += m
        e += 2 * (dy - dx)
    else:
        e += 2 * dy
						\end{lstlisting}
						\caption{Fragment kodu algorytmu}
					\end{minipage}
					\hfill
					\begin{minipage}{0.45\linewidth}
						\includegraphics[width=\textwidth]{img/bresenham.png}
						\caption{Przykład działania -- znajdowanie pikseli między dwoma czerwonymi}
					\end{minipage}
				\end{figure}
				
				Znając wszystkie piksele leżące między emiterem, a detektorem, 
				sumujemy ich jasność i zapisujemy w odpowiednim miejscu sinogramu.
				Na koniec normalizujemy wszystkie dane, tak aby wartości były z~przedziału od~0~do~1. W tym celu znajdujemy największą wartość (najjaśniejszy piksel) i dzielimy przez nią pozostałe.
				
				\subsubsection{Obraz wynikowy}
				Sinogram nie jest zrozumiały dla człowieka, 
				dlatego należy go przekształcić.
				Zaczynamy od czarnego obrazu i znów przejdziemy przez n iteracji.
				Każdej iteracji przypisana będzie pozycja emitera wraz z~detektorami 
				(będą to te same pozycje, co podczas generowania sinogramu).
				Wyznaczamy linie przechodzące przez obraz między emiterem i detektorami (algorytm Bresenhama).
				Każdy piksel, przez który przechodzi linia będzie rozjaśniony o wartość odczytaną z sinogramu 
				(dla danego detektora w danej iteracji). 
				Nałożenie wszystkich linii na obrazie stworzy obraz wynikowy.
				{\color{red} to samo co wyżej, no i myślę jeszcze o jakiś obrazkach}
			\subsection{Standard DICOM}
			Wyniki zapisujemy w standardzie DICOM. 
			{\color{red} Czy mam opisywać co to jest za standard?}
			Do obsługi standardu używamy biblioteki \texttt{pydicom}. W pliku, oprócz samego skanu, zapisujemy też dane pacjenta (imię i nazwisko, płeć, datę urodzenia), komentarze, datę i czas badania. Wykorzystujemy w tym celu następujące pola:
			\begin{figure}[!h]
				\centering
				\begin{tabular}{|c|c|c|}
				\hline
				\textbf{Identyfikator pola} & \textbf{Nazwa pola} & \textbf{Opis} \\
				\hline \hline
				(0008, 0023) & Content Date & data badania \\
				\hline
				(0008, 0033) & Content Time & czas badania \\
				\hline
				(0010, 0010) & Patient's Name & imię i nazwisko pacjenta \\
				\hline
				(0010, 0030) & Patient's Birth Date & data urodzenia pacjenta \\
				\hline
				(0010, 0040) & Patient's Sex & płeć pacjenta \\
				\hline
				(0010, 4000) & Patient Comments & komentarze \\
				\hline
				(0028, 0010) & Rows & liczba wierszy obrazka (wysokość) \\
				\hline
				(0028, 0011) & Columns & liczba kolumn obrazka (szerokość) \\
				\hline
				(7fe0, 0010) & Pixel Data & obrazek (piksele) \\
				\hline
				\end{tabular}
				\caption{Niektore z wykorzystanych pól}
			\end{figure}
			\newpage
			Fragment kodu odpowiedzialnego za zapis pokazuje rysunek \ref{dicomsave}. Do odczytu pliku skorzystaliśmy z funkcji \texttt{pydicom.dcmread(filename)}, która pozwala następnie na dostęp do wszystkich pól z pliku.
			{\color{red} Czy dodać kod odczytu pliku?}
			
			\begin{figure}[!h]
				\centering
				\begin{lstlisting}[language=Python, frame=single]
ds = FileDataset(filename, {}, file_meta=file_meta, preamble=b"\0" * 128)
ds.PatientName = name
ds.PatientSex = sex
ds.PatientBirthDate = birth.strftime('%Y%m%d')
ds.PatientComments = comment

ds.ContentDate = date.strftime('%Y%m%d')
ds.ContentTime = date.strftime('%H%M%S.%f')

# 1 lub 3 - ile kolorow na obrazie
ds.SamplesPerPixel = 1
# interpretacja (MONOCHROME, RGB, HSV, ...)
ds.PhotometricInterpretation = "MONOCHROME2"
# 0 - unsigned int, 1 - U2
ds.PixelRepresentation = 0
# najwyzszy bit
ds.HighBit = 15
# ilosc bitow na piksel
ds.BitsStored = 16
# ilosc bitow zaalokowanych na piksel
ds.BitsAllocated = 16
# minimalna wartosc piksela - 0
ds.SmallestImagePixelValue = str.encode('\x00\x00')
# maksymalna wartosc piksela - ffff?
ds.LargestImagePixelValue = str.encode('\xff\xff')
# kolumny, wiersze i dane
ds.Columns = image.shape[1]
ds.Rows = image.shape[0]
ds.PixelData = (image * 65535).astype('uint16').tobytes()

ds = correct_ambiguous_vr(ds, True)
ds.save_as(filename, write_like_original=False)
				\end{lstlisting}
				\caption{Fragment kodu -- zapis do pliku DICOM}
				\label{dicomsave}
			\end{figure}
			
\end{document}
